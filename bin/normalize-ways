#!/usr/bin/env node --max_old_space_size=4096

'use strict';

var byline = require('byline');
var fs = require('graceful-fs');
var path = require('path');
var geojsonLR = require('@mapbox/geojson-lr');
var clonedeep = require('lodash.clonedeep');
var jsonBigInt = require('json-bigint');
var pairsToWays = require('../lib/pairs-to-ways');
var indexWay = require('../lib/index-way');
var splitWays = require('../lib/split-ways');
var mergeWays = require('../lib/merge-ways');
var argv = require('minimist')(process.argv.slice(2));

var quadHash = {};

var outputPath = argv.outputPath;
var waysFile = argv.waysFile;
var zoomLevel = argv.zoomLevel;
var openLR = argv.openLR;
var options = {};

options.mergeHighways = (argv.mergeHighways !== undefined) ? JSON.parse(argv.mergeHighways) : false;
options.mergeTunnels = (argv.mergeTunnels !== undefined) ? JSON.parse(argv.mergeTunnels) : false;
options.mergeBridges = (argv.mergeBridges !== undefined) ? JSON.parse(argv.mergeBridges) : false;
options.mergeMaxspeed = (argv.mergeMaxspeed !== undefined) ? JSON.parse(argv.mergeMaxspeed) : false;

var waysStream = byline(fs.createReadStream(waysFile), {encoding: 'utf8'});

waysStream.on('data', function (line) {
  // hash ways into the quadHash

  let way = jsonBigInt.parse(line);

  // parse refs if they are in string format
  if (typeof way.properties.refs === 'string') {
    way.properties.refs = way.properties.refs.split(',');
  }

  // parse coordinates as float
  way.geometry.coordinates = way.geometry.coordinates.map(function(x) {
    return [parseFloat(x[0]), parseFloat(x[1])];
  });

  // throw out ways that have a different number of refs vs coordinates
  if (way.properties.refs !== undefined && way.geometry.coordinates.length === way.properties.refs.length) {
    // index the way's segments into z14 tiles
    let tileQuadkeys = indexWay(way, zoomLevel);

    // Consolidate each quadkey's pairs into way slices,
    // and add them to the quadHash, a hash from quadkey to ways.
    Object.keys(tileQuadkeys).forEach(function (quadkey) {

      let pairs = tileQuadkeys[quadkey];
      let tileWays = pairsToWays(pairs);
      for (let k = 0, n = tileWays.length; k < n; k++) {
        let tileWay = tileWays[k];

        // Differenciate each part of the way by appending to its id
        tileWay.properties.id = way.properties.id + '|' + k;

        // persist highway, oneway, bridge, tunnel and maxspeed tags if present
        tileWay.properties.highway = way.properties.highway;
        tileWay.properties.oneway = way.properties.oneway;
        tileWay.properties.bridge = way.properties.bridge;
        tileWay.properties.tunnel = way.properties.tunnel;
        tileWay.properties.maxspeed = way.properties.maxspeed;
        if (quadHash[quadkey] === undefined) quadHash[quadkey] = [];
        quadHash[quadkey].push(tileWay);
      }
    });
  }
}).on('end', function () {
  // once all ways are processed, normalize each
  // quadkey's ways and write them to disk.
  Object.keys(quadHash).forEach(function (quadkey) {
    var ways = quadHash[quadkey];

    ways = splitWays(ways);
    ways = mergeWays(ways, options);

    var outputStream = fs.createWriteStream(path.join(outputPath, quadkey + '.json'));
    for (var i = 0; i < ways.length - 1; i++) {
      var way = ways[i];
      way.properties.id = way.properties.id + ';' + quadkey;
      if (openLR) {
        way.properties.openLR = geojsonLR.toOpenLRString(way);
        if (way.properties.oneway === 0) {
          way.properties.reverseOpenLR = geojsonLR.toOpenLRString(reverseWay(way));
        }
      }
      outputStream.write(jsonBigInt.stringify(way) + '\n');
    }
    way = ways[ways.length - 1];
    way.properties.id = way.properties.id + ';' + quadkey;
    if (openLR) {
      way.properties.openLR = geojsonLR.toOpenLRString(way);
      if (way.properties.oneway === 0) {
        way.properties.reverseOpenLR = geojsonLR.toOpenLRString(reverseWay(way));
      }
    }
    outputStream.write(jsonBigInt.stringify(way));
    outputStream.end();
  });
});

function reverseWay(way) {
  let reverseWay = clonedeep(way);
  reverseWay.geometry.coordinates.reverse();
  reverseWay.properties.refs.reverse();
  return reverseWay;
}
